Dynamically Reallocateable Arrays

Dynamic arrays (as we've shown them) already provide a very powerful capability to a programmer, and this feature alone can dramatically affect how an application would be designed. Linked lists, however, still have the advantage that they can grow (shrink) in size after they are initially allocated, depending upon the demands of the application.

Using the basis of the dynamic array that we've already seen, C goes beyond the malloc() function and provides the realloc() function. This gives us the ability to change the size of a dynamic array, AND properly maintain any data that has already been loaded into it.

Here is the general syntax for the realloc() function:

arrayname = (type *) realloc (arrayname,newsize * sizeof(type));

Using the da dynamic array from the previous example, let's increase its size from 4 integers to 6 -- and we want to make sure the original four values are unaffected by the increase in size. Here is the call to realloc():

da = (int *) realloc (da,6 * sizeof(int));

This is what memory will look like when realloc() is finished:
NOTE that C++ does not have an equivalent function for realloc() that can be used with new.
To gain this capability, you would have to perform these four steps yourself, making sure your object had the proper method to handle copying its internal data values to the new version.

Here is an example program showing the simple use of a dynamically reallocateable array. The user is prompted for a series of integer values until he enters 0. These values are added to the dynamic array, as the numbers are entered, increasing the size of the array as it goes. It will then print the contents of the array, and then free it.

Also NOTE that the very first allocation is not considered a special case. We don't have to use malloc() the first time. If the pointer is initially set to NULL, realloc() acts the same as malloc().

#include <cstdlib>
#include <iostream>

using namespace std;

#define dountilbreak  while (1)

int main (void) {
  int *intarray = NULL;
  int num, numValues = 0;

  dountilbreak {  // Build the dynamic array
    cout << "Enter num (0 to stop): " << flush;
    cin >> num;
    if (num == 0) break;
    intarray = (int *) realloc (intarray,
                          (numValues+1) * sizeof(int));
    intarray[numValues++] = num;
    }

  // Print the array
  for (int i=0; i < numValues; i++)
    cout << intarray[i] << endl;

  // Finally, free the array
  free (intarray);
  
  return 0;
}

All you declare is a pointer that will point to the dynamic array of pointers. When you add an element to the array, you now need two steps:

    You increase the size of the array of pointers;
    You dynamically allocate an element and assign its address to the new element in the array of pointers 

Here is the generalized sequence of instructions to add an element:


array = (type **) realloc (array,(numElements+1) * sizeof(type *));
array[numElements] = (type *) malloc (sizeof(type));
Load array[numElements] with data
numElements++;


Here is an example using a dynamic array of strings:

#include <cstdlib>
#include <iostream>
#include <string>

using namespace std;

int main (void) {
  char **strarray = NULL;
  int i, numStrings = 0;
  char line[80+1];
  
  while (1) {  // Build the dynamic array of strings
    cout << "Enter a string (Enter to stop): " << flush;
    cin.getline(line,80);
    if (strlen(line) == 0) break;
    
    strarray = (char **) realloc (strarray,
                            (numStrings+1) * sizeof(char *));
    strarray[numStrings++] = strdup(line);
    }
    
  // Display the array
  for (i=0; i < numStrings; i++)
    cout << strarray[i] << endl;
    
  // Free the array: You MUST delete each individual 
  //   string before you delete the array of pointers
  for (i=0; i < numStrings; i++)
    free (strarray[i]);
  free (strarray);
  
  return 0;
}

Now we show an example that uses a more complicated structure:

#include <cstdlib>
#include <iostream>

using namespace std;

struct RECORD {
  char name[30+1];
  char address[40+1];
  float salary;
  };

int main (void) {
  int numElements = 0;
  RECORD rec, **recarray = NULL;
  FILE *infile = fopen("infile.dat","rb");

  while (!feof(infile)) { // Load the array of records

    fread (&rec,1,sizeof(REC),infile);
    if (feof(infile)) break;

    recarray = (RECORD **) realloc 
                       (recarray,(numElements+1) * sizeof(RECORD *));
    recarray[numElements] = (RECORD *) malloc (sizeof(RECORD));
    *recarray[numElements++] = rec;
    }
  fclose (infile);

  // Display the values loaded
  for (int i=0; i < numElements; i++)
    cout << recarray[i]->name << endl;

  return 0;
}

When trying to create a dynamic array of object classes in C++, you still can use the realloc() function for the array of pointers to the object class, yet new will need to be used for the allocation of the class itself in order for the constructor method to be called. Here is an example demonstrating this

#include <cstdlib>

using namespace std;

class DEMO {
  ...
};


DEMO **array = NULL;
int num = 0;

while (1) {
  
  array = (DEMO **) realloc (array,(num+1) * sizeof(DEMO *));
  array[num++] = new DEMO;
  
  // To reference a method in one of the classes
  array[index]->method();
  
  }



